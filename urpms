#!/bin/bash
#
# +-----------------------------------------------------------------------------------+
# | Copyright (C) 2019 David Vasquez                                                  |
# | MIT license                                                                       |
# | Permission is hereby granted, free of charge, to any person obtaining a copy of   |	
# | this software and associated documentation files (the "Software"), to deal in the | 
# | Software without restriction, including without limitation the rights to use,     |
# | copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the   | 
# | Software, and to permit persons to whom the Software is furnished to do so,       |
# | subject to the following conditions:                                              |
#
# | The above copyright notice and this permission notice shall be included in all    | 
# | copies or substantial portions of the Software.                                   |
#                                                       
# | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR        |
# | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS  |
# | FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR    |
# | COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN |
# | AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION   |
# | WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                   |                                                 
# +-----------------------------------------------------------------------------------+
# | This code is designed, written and maintained by David Vasquez    		      |
# | Any questions, comments or advice on this code                                    |
# | should be addressed to:                                                           |
# | davidva@tutanota.com                                                              |
# +-----------------------------------------------------------------------------------+

#directory=/root/build
#repodirectory=/root/OneDrive/unitedrpms/updates/$(rpm -E %fedora)
#MOCK_DEF_PATH=${directory}/mock
#date=$(date +%Y%m%d_%H:%M:%S)

usage() {
  echo ""
  echo -e '\e[33m  -g url_git\e[0m'
  echo "    The git hub name user and project, example UnitedRPMs/ffmpeg"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -t fedora-24-x86_64 -u true"
  echo ""
  echo -e '\e[33m  -i imputgit\e[0m'
  echo "    Make rpm from a specific git branch"
  echo "Usage: $0 -i UnitedRPMs/ffmpeg -s ffmpeg.spec -r true -d 'dist .fc29' -i 29 -u true"
  echo ""
  echo -e '\e[33m  -f SRPM\e[0m'
  echo "    Rebuild a src.rpm from remote url (beta)"
  echo "Usage: $0 -t fedora-25-x86_64 -f http:www.foo/ffmpeg-foo.src.rpm "
  echo ""
  echo -e '\e[33m  -e SNAPSHOT\e[0m'
  echo "    Generate the source file with a special script example ffmpeg-snapshot.sh (beta)"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -t fedora-25-x86_64 -e ffmpeg-snapshot.sh "
  echo ""
  echo -e '\e[33m  -r NO_MOCK\e[0m'
  echo "    Generate a rpm without mock, super fast"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -r true -d 'dist .fc25' -u true"
  echo "--------------------------------------"
  echo "  -s SPECfile"
  echo '    The name of the RPM SPEC file, example "-s ffmpeg.spec" '
  echo "  -t TARGET"
  echo '    mock config example "-t fedora-26-x86_64" '
  echo "  -d DIST"
  echo "    Distribution number, only works with NO_MOCK; example: -r true -d 'dist .fc25' -u true"
  echo "  -u UPP"
  echo "    Unique build, avoids build without a massive task of sub-requires ; example: -r true -d 'dist .fc25' -u true"
  exit 1
}

readargs() {
  while [ "$#" -gt 0 ] ; do
    case "$1" in
       -s)
        if [ "$2" ] ; then
          specfile="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -t)
        if [ "$2" ] ; then
          TARGET="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -p)
        if [ "$2" ] ; then
          TOKENG="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -g)
        if [ "$2" ] ; then
          url_git="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -b)
        if [ "$2" ] ; then
          massive_spec="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -c)
        if [ "$2" ] ; then
          CLOUD="$2" 
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -d)
        if [ "$2" ] ; then
          DIST="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -i)
        if [ "$2" ] ; then
          imputgit="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -n)
        if [ "$2" ] ; then
          no_who_requires="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -e)
        if [ "$2" ] ; then
          SNAPSHOT="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -f)
        if [ "$2" ] ; then
          SRPM="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -r)
        if [ "$2" ] ; then
          NO_MOCK="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -u)
        if [ "$2" ] ; then
          UPP="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -w)
        if [ "$2" ] ; then
          REPOCLOUD="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      *)
        echo "Unknown option or argument $1."
        echo
        shift
        usage
      exit
      ;;
    esac
  done
}


checkargs() {
 if [ -z "${TARGET}" ] && [ "${NO_MOCK}" = true ]; then
    echo 'Using rpmbuild mode'
 elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
    echo 'Using mock mode'
 elif [ -z "${TARGET}" ] && [ -z "${NO_MOCK}" ] ; then
    echo -e '\e[31mMissing target, example your need add "-t fedora-30-x86_64"\e[0m'
    usage
exit
  fi
}

SRPMcheck() {
name_build
counting=$( ls -1 ${directory}/rpmbuild/GIT/${name}/SRPMS/ | grep "${name}" | grep .src.rpm | wc -l )
if [ "${counting}" -ge 2 ]; then
# find $PWD/SRPMS/ -name "${name}-*.src.rpm" -mmin -2 -exec rm -f {} ';'
rm -f $( dnf -y repomanage --keep=1 --new $PWD/SRPMS/ )
exit 1
fi

ass=$(ls ${repodirectory}/${name_spec}-[0-9]*.src.rpm 2> /dev/null | wc -l)
if [ "$ass" != "0" ]; then
echo "${name} is already built"
exit 0
fi

bsource=$(ls ${directory}/rpmbuild/GIT/${name}/SRPMS/${name_spec}-[0-9]*.src.rpm 2> /dev/null | wc -l)
if [ "$bsource" != "0" ]; then
   echo -e "\e[36mExists src.rpm of ${name}, great\e[0m"
else
echo "Hey the src.rpm of ${name} does not exist; check your urls in sources; date in changelog and patches"
exit 1
fi
}

name_build() {
name=$( echo "${url_git##*/}" )
if [ -d ${directory}/rpmbuild/GIT/${name}/ ]; then
name_spec=$( rpm -q --qf "%{Name}\n" --specfile ${directory}/rpmbuild/GIT/${name}/${specfile} | head -1)
fi
}

path_chroot() {
chrootmock=${directory}/mock/${TARGET}/result
}

sign_rpm() {
rpm --define "_gpg_name The UnitedRPMs Project" --addsign *.rpm
}

make_directory_task() {
echo -e "\e[32mCreating job directories...\e[0m"
  mkdir -p ${directory}/rpmbuild/{RPMS,BUILD,SOURCES,SRPMS,GIT}
  mkdir -p ${repodirectory}
  mkdir -p ${MOCK_DEF_PATH}
  mkdir -p ${MOCK_DEF_PATH}/cache
  mkdir -p /root/.config/
}

git_task() {
echo -e "\e[32mCloning repository ${url_git}...\e[0m"
name_build
rm -rf ${directory}/rpmbuild/GIT/*
git clone https://github.com/${url_git}.git ${directory}/rpmbuild/GIT/${name}
if [ -n "${imputgit}" ]; then
pushd ${directory}/rpmbuild/GIT/${name}
git checkout --force "${imputgit}"
popd
elif [ -z "${imputgit}" ]; then
pushd ${directory}/rpmbuild/GIT/${name}
git checkout --force master
popd
fi
if [ ! -f ${directory}/rpmbuild/GIT/${name}/${specfile} ]; then
echo 'Hey check if your git repository exists!'
exit 1
fi
}


detect_local_package() {
# We need detect packages already built in our local repository, useful for avoid bucles in massive rebuild
s_inrepo=$(ls ${repodirectory}/${name}-*.src.rpm 2> /dev/null | wc -l)
p_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).$(uname -m).rpm 2> /dev/null | wc -l)
n_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).noarch.rpm 2> /dev/null | wc -l)
if [ "$s_inrepo" != "0" ] && [ "$p_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
elif [ "$s_inrepo" != "0" ] && [ "$n_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
else
echo "Package ${name} not found in local repository; then we will attempt make a rpm for you, are you already test your package?"
if [ -f "/tmp/${name}.prb" ]; then
echo "ERROR loop detected with ${name} check your spec file changelog sources and patches"
exit
fi

fi
}

svnsources() {
if [ $( cat *.spec | grep -c svn_url ) -gt 0 ]; then
if [ ! -f /usr/bin/svn ]; then
dnf -y install subversion
fi
svn_name=$( cat *.spec | grep -e 'Name:' -e 'name:' | awk '{print $2}' )
REV=$( cat ${svn_name}.spec | grep -e '%global svn_rev' | awk '{print $3}' )
svn_url=$( cat ${svn_name}.spec | grep -e '%global svn_url' | awk '{print $3}' )
rm -rf ${svn_name}-${REV}/
rm -f ${svn_name}-${REV}.tar.gz
svn checkout --non-interactive --revision ${REV} ${svn_url} ${svn_name}-${REV}
pushd ${svn_name}-${REV}
echo "You are in Revision:$( svnversion . )"
popd
tar -czf ${svn_name}-${REV}.tar.gz ${svn_name}-${REV}
rm -rf ${svn_name}-${REV}/
fi
}

run_ping() {
status=$(curl -I "https://sourceforge.net/" 2> /dev/null | head -n 1 | cut -d ' ' -f 2)
 
if [ ${status} -eq 200 ]; then
	echo 'PING OK'
else
echo 'SF or your conection is DOWN!'
exit 1
fi
}

cloudbuilt() {
if [ $( echo ${url_git} | grep -c UnitedRPMs) -gt 0 ] && [ "${CLOUD}" = true ] && [ "${REPOCLOUD}" = true ]; then
pushd ${repodirectory}
onedrive -v --synchronize
createrepo_c --database --compatibility ./
dnf -y clean metadata 
popd
fi
}


buildrpm() {
# Our build task
# We need detect packages already built in our local repository, useful for avoid bucles in massive rebuild
s_inrepo=$(ls ${repodirectory}/${name}-*.src.rpm 2> /dev/null | wc -l)
p_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).$(uname -m).rpm 2> /dev/null | wc -l)
n_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).noarch.rpm 2> /dev/null | wc -l)
if [ "$s_inrepo" != "0" ] && [ "$p_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
elif [ "$s_inrepo" != "0" ] && [ "$n_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
else
echo "Package ${name} not found in local repository; then we will attempt make a rpm for you, are you tested your package?"
if [ -f "/tmp/${name}.prb" ]; then
echo "ERROR loop detected with ${name}check your spec file changelog sources and patches"
exit
fi
 fi

echo -e "\e[32mMaking an rpm source...\e[0m"
name_build
  pushd ${directory}/rpmbuild/GIT/${name}/
if [ -n "${SNAPSHOT}" ]; then
echo 'Snapshot enabled'
  chmod a+x ${SNAPSHOT}
  ./${SNAPSHOT}
  pushd ${directory}/rpmbuild/GIT/${name}/
  find . -name \*.tar.* -exec cp {} $PWD \;
fi
if [ "${massive_spec}" = true ]; then
  Inrelease 
#  Pushaugit
fi
  svnsources
  spectool -g "${specfile}" && spectool -g "${specfile}"
  rpmbuild --define "_topdir $PWD" --define "_sourcedir $PWD" -bs "${specfile}"
echo -e "\e[32mMaking rpm for ${name}...\e[0m"
run_ping
cloudbuilt
re_enabling_repos
# if the build is without mock
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
SRPMcheck
# We need disabled unitedrpms repository for a new and clean build in unibuild-basic
if [ "${name}" = unibuild-basic ]; then
dnf -y config-manager --set-disabled unitedrpms
fi
  dnf -y clean all && rm -rf /var/lib/dnf/history 
security_updates=$( dnf -y -q updateinfo list --security | awk '{print $3}' )
if [ -n "$security_updates" ]; then
  dnf -y update "$security_updates"
else
  dnf -y update 
fi
  dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms && dnf -y update mock-core-configs
  chroot_dependency
  dnf -y builddep "${specfile}" 
  rpmbuild --define "_topdir $PWD" --define "${DIST}" --rebuild $PWD/SRPMS/${name}-*.src.rpm | tee ${repodirectory}/build.log
if [ -n $PWD/RPMS/x86_64/${name}-[0-9]*.fc$(rpm -E %fedora).$(uname -m).rpm ] || [ -n $PWD/RPMS/i686/${name}-[0-9]*.fc$(rpm -E %fedora).i686.rpm ] || [ -n $PWD/RPMS/noarch/${name}-[0-9]*.fc$(rpm -E %fedora).noarch.rpm ]; then
echo "Successful build for ${name}"
else
echo "Failed build ${name}, check your '%prep, %build, %install' others Sections; src.rpm made"
fi
cp -n RPMS/x86_64/* ${repodirectory}/
cp -n RPMS/i686/* ${repodirectory}/
cp -n RPMS/noarch/* ${repodirectory}/
cp -n SRPMS/* ${repodirectory}/
pushd "${repodirectory}"
if [ $(ls *.rpm | grep -c .rpm) -gt 0 ]; then
dnf -y install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
fi
popd
# If the build is with mock 
elif [ -n "${TARGET}" ] && [ "${NO_MOCK}" != true ] || [ -z "${NO_MOCK}" ]; then
SRPMcheck
  /long-living-command &
dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms && dnf -y update mock-core-configs
# Conditional to accelerate the build
if [ -f importantbump ]; then
  /usr/bin/mock -r ${TARGET} --no-clean --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/${name}-*.src.rpm  
else
  /usr/bin/mock -r ${TARGET} --no-cleanup-after --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/${name}-*.src.rpm  
fi
# End conditional accelerate the build
if [ -n ${MOCK_DEF_PATH}/${name}-[0-9]*.fc$(rpm -E %fedora).$(uname -m).rpm ] || [ -n ${MOCK_DEF_PATH}/${name}-[0-9]*.fc$(rpm -E %fedora).i686.rpm ] || [ -n ${MOCK_DEF_PATH}/${name}-[0-9]*.fc$(rpm -E %fedora).noarch.rpm ]; then
echo "Successful build for ${name}"
else
echo "Failed build ${name}, check your '%prep, %build, %install' others Sections; src.rpm made"
fi
fi
  popd
local_repo
# Our conditional for build a unique build
if [ "${UPP}" = true ] && [ -z "${no_who_requires}" ]; then
echo 'UNIQUE BUILD'
else
massdependency
fi
# End unique build conditional

# Delete trash
if [ -f /tmp/stop ]; then
rm -f /tmp/stop
fi
#

# Conditional for sync to Cloud 
if [ "${CLOUD}" = true ]; then
upload_rpm
fi
# End conditional CLOUD
}

local_repo() {
# Our local repo; useful in massive rebuild
enjoy_repo
path_chroot
name_build
echo -e "\e[32mMaking local repository...\e[0m"
pushd ${MOCK_DEF_PATH}/
cp -f *.rpm ${repodirectory}/ 
 popd
pushd "${repodirectory}"
rm -rf repodata/
 rm -f $( dnf -y repomanage --keep=1 --old $PWD )
sign_rpm
createrepo_c --database ./
#
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
dnf -y clean expire-cache
if [ "$(ls -A $PWD)" ]; then
     echo "Great $PWD is not Empty"
dnf -y install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
fi
elif [ -z "${NO_MOCK}" ] && [ -n "${TARGET}" ]; then
if [ "$(ls -A $PWD)" ]; then
     echo "Great $PWD is not Empty"
mock -r "${TARGET}" --install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
fi
fi
#
popd
}

enjoy_repo() {

if [ ! -d "${repodirectory}" ]; then
mkdir -p "${repodirectory}"
fi

if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ] && [ "${massive_spec}" != true ]; then
echo '
[enjoy]
name=enjoy
failovermethod=priority
baseurl=file:///root/OneDrive/unitedrpms/updates/$releasever
enabled=1
priority=1
skip_if_unavailable=1
gpgcheck=0
exclude=*.src.rpm
' > /etc/yum.repos.d/enjoy.repo
elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ] && [ "${massive_spec}" != true ]; then
if [ ! -f /etc/mock/${TARGET}.cfg ]; then
echo 'The build config mock does not exist'
echo 'Check your configuration or update your mock package'
usage
exit 1
fi
echo '
[enjoy]
name=enjoy
failovermethod=priority
baseurl=file:///root/OneDrive/unitedrpms/updates/$releasever/
enabled=1
priority=1
skip_if_unavailable=1
gpgcheck=0
exclude=*.src.rpm
' > changdata.txt 

mock_conf=$( echo ${TARGET} | awk -F '-' '{print $2}' | awk -F '-' '{print $1}')
sed -i 's|$releasever|$mock_conf|g' changdata.txt

f1="$(<changdata.txt)"
awk -vf1="$f1" '/# repos/{print;print f1;next}1' /etc/mock/${TARGET}.cfg | tee /tmp/new_repo.cfg
pushd /etc/mock/
mv -f /tmp/new_repo.cfg ${TARGET}.cfg
 popd
fi
}

upload_rpm() {
echo -e "\e[32mUploading results...\e[0m"
pushd "${repodirectory}"
sign_rpm

if [ -n "${TARGET}" ]; then
pushd ${MOCK_DEF_PATH}
mkdir -p /root/OneDrive/unitedrpms/mock_logs/
cp -f build.log /root/OneDrive/unitedrpms/mock_logs/${name}_${date}_build.log
mv -f root.log /root/OneDrive/unitedrpms/mock_logs/${name}_${date}_root.log
mv -f state.log /root/OneDrive/unitedrpms/mock_logs/${name}_${date}_state.log
popd
fi

onedrive -v --synchronize 


zlog=$( du -k build.log | cut -f1 )
b=800
if [ -n "${TARGET}" ] && [ $zlog \> $b ] || [ "${massive_spec}" = true ] || [ "${NO_MOCK}" = true ]; then
echo 'This log is too long to be displayed'
elif [ -n "${TARGET}" ] && [ "$b" -gt "$zlog" ]; then
cat build.log
fi
}

rules_directory() {
# I am not sure, we are root...
chown -R 1000:1000 ${directory}
chown -R 1000:1000 ${repodirectory}
# chown -R 1000:1000 ${MOCK_DEF_PATH}
chmod g+rws ${MOCK_DEF_PATH}
chmod g+rws ${MOCK_DEF_PATH}/cache
}


performance_mock() {
# NO TOUCH OR ENABLE IT! It alters the mock function
echo 'config_opts['basedir'] = '/home/makerpm/mock/'
config_opts['cache_topdir'] = '/home/makerpm/mock/cache'
config_opts['use_container_host_hostname'] = True
config_opts['docker_unshare_warning'] = False
config_opts['nosync_force'] = True
config_opts['plugin_conf']['tmpfs_enable'] = True
config_opts['plugin_conf']['tmpfs_opts'] = {}
config_opts['plugin_conf']['tmpfs_opts']['required_ram_mb'] = 1024
config_opts['plugin_conf']['tmpfs_opts']['max_fs_size'] = '50g'
config_opts['plugin_conf']['tmpfs_opts']['mode'] = '0755'
config_opts['plugin_conf']['tmpfs_opts']['keep_mounted'] = False
' > perf.txt

f1="$(<perf.txt)"
awk -vf1="$f1" '/package_manager/{print;print f1;next}1' /etc/mock/${TARGET}.cfg | tee /tmp/new_perf.cfg
pushd /etc/mock/
mv -f /tmp/new_perf.cfg ${TARGET}.cfg
 popd
}

check_depends() {
# only necessary in Performance mock task
if [ ! -f /usr/lib64/nosync/nosync.so ]; then
dnf -y install nosync 
fi
}

up_ornew() {
# The filer for a initial package or unique, useful in new versions of fedora
echo 'no_build' > /tmp/stop
if [ ${name} = ffmpeg ]; then
echo 'ffmpeg_build' >> /tmp/stop
elif [ ${name} = x264 ]; then
echo 'x264_build' >> /tmp/stop
elif [ ${name} = x265 ]; then
echo 'x265_build' >> /tmp/stop
elif [ ${name} = libbluray ]; then
echo 'libbluray_build' >> /tmp/stop
elif [ ${name} = live555 ]; then
echo 'live555_build' >> /tmp/stop
elif [ ${name} = kodi ]; then
echo 'kodi_build' >> /tmp/stop
elif [ ${name} = libquicktime ]; then
echo 'libquicktime_build' >> /tmp/stop
elif [ ${name} = gstreamer1-plugins-base ]; then
echo 'gstreamer1-plugins-base_build' >> /tmp/stop
elif [ ${name} = libopenshot ]; then
echo 'libopenshot_build' >> /tmp/stop
elif [ ${name} = libshout-idjc ]; then
echo 'libshout-idjc_build' >> /tmp/stop
elif [ ${name} = openh264 ]; then
echo 'openh264_build' >> /tmp/stop
elif [ ${name} = faad2 ]; then
echo 'faad2_build' >> /tmp/stop
elif [ ${name} = faac ]; then
echo 'faac_build' >> /tmp/stop
elif [ ${name} = libaacs ]; then
echo 'libaacs_build' >> /tmp/stop
elif [ ${name} = vmaf ]; then
echo 'vmaf_build' >> /tmp/stop
fi
}

massrebuild() {
# Our massive task
if [ -f importantbump ] && [ ! -f /tmp/unibuild_basic.log ] || [ $( cat /tmp/stop | grep -c -e ffmpeg_build -e x264_build -e x265_build -e libbluray_build -e live555_build -e kodi_build -e libquicktime_build -e gstreamer1-plugins-base_build -e libopenshot_build -e libshout-idjc_build -e openh264_build -e faad2_build -e faac_build -e libaacs_build -e vmaf_build ) -lt 1 ]; then
echo "MASS REBUILD TASK FOR ${name}"
file=importantbump

if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ] && [ ! -f /tmp/stop ]; then
local_install_packages
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -r true -d "${DIST}" -b true -u true
done <"$file"
local_repo

elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ] && [ ! -f /tmp/stop ]; then
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -t "${TARGET}" -b true -u true
done <"$file"
local_repo
fi
  fi

# FIRST BUILD
if [ -f importantbump ] && [ -f /tmp/unibuild_basic.log ] || [ $( cat /tmp/stop | grep -c -e ffmpeg_build -e x264_build -e x265_build -e libbluray_build -e live555_build -e kodi_build -e libquicktime_build -e gstreamer1-plugins-base_build -e libopenshot_build -e libshout-idjc_build -e openh264_build -e faad2_build -e faac_build -e libaacs_build -e vmaf_build ) -gt 0 ]; then
echo 'FIRST BUILD TASK'
file=importantbump
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
local_install_packages
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -r true -d "${DIST}" -b true -u true
done <"$file"
local_repo
elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -t "${TARGET}" -b true -u true
done <"$file"
local_repo
fi
 fi
}

massdependency() {
# Some times we need a filter with massive rebuild... the /tmp/stop (dummy) makes a special build wihout packages dependent of the current build.
# importantbump, is a list of all packages dependent of the current build (called massive rebuild)
name_build
if [ "${name}" = x264 ]; then
up_ornew
echo 'ffmpeg
libquicktime
mplayer
gstreamer1-plugins-ugly
gstreamer-plugins-ugly
avidemux
handbrake
obs-studio
vlc' > importantbump
massrebuild
elif [ "${name}" = x265 ]; then 
up_ornew
echo 'ffmpeg
avidemux
handbrake
gstreamer1-plugins-bad-freeworld
vlc
mpv' > importantbump
massrebuild
elif [ "${name}" = ffmpeg ]; then
up_ornew
if [ -f importantbump ]; then
echo 'xine-lib
gstreamer-ffmpeg
libquicktime
mlt
libopenshot
idjc
minidlna
mplayer
mpd
mpv
moc
obs-studio
simplescreenrecorder
vlc
kodi
deadbeef
audacity-freeworld' >> importantbump
elif [ ! -f importantbump ]; then
echo 'xine-lib
gstreamer-ffmpeg
libquicktime
mlt
libopenshot
idjc
minidlna
mplayer
mpd
mpv
moc
obs-studio
simplescreenrecorder
vlc
kodi
deadbeef
audacity-freeworld' > importantbump
fi
massrebuild
elif [ "${name}" = libquicktime ] && [ ! -f /tmp/stop ]; then
# dnf repoquery --whatrequires libquicktime --source | grep -v libquicktime | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
up_ornew
if [ -f importantbump ]; then
echo 'mjpegtools' >> importantbump
else
echo 'mjpegtools' > importantbump
fi
massrebuild
elif [ "${name}" = gstreamer1 ]; then
echo 'gstreamer1-plugins-base
gstreamer1-plugins-good
gstreamer1-plugins-bad-free
gstreamer1-plugins-bad-nonfree
gstreamer1-plugins-bad-freeworld
gstreamer1-plugins-ugly
gstreamer1-libav 
gstreamer1-vaapi' > importantbump
massrebuild
elif [ "${name}" = gstreamer1-plugins-base ]; then
up_ornew
if [ ! -f importantbump ]; then
echo 'gstreamer1-plugins-good
gstreamer1-plugins-bad-free
gstreamer1-plugins-bad-nonfree
gstreamer1-plugins-bad-freeworld
gstreamer1-plugins-ugly
gstreamer1-libav 
gstreamer1-vaapi' > importantbump
elif [ -f importantbump ]; then
echo 'gstreamer1-plugins-good
gstreamer1-plugins-bad-free
gstreamer1-plugins-bad-nonfree
gstreamer1-plugins-bad-freeworld
gstreamer1-plugins-ugly
gstreamer1-libav 
gstreamer1-vaapi' >> importantbump
fi
massrebuild
elif [ "${name}" = live555 ]; then
# dnf repoquery --whatrequires live555 --source | grep -v libquicktime | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
up_ornew
if [ -f importantbump ]; then
echo 'vlc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'vlc' > importantbump
fi
massrebuild
elif [ "${name}" = libbluray ]; then
up_ornew
# dnf repoquery --whatrequires libbluray --source | grep -v libbluray | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'xine-lib
ffmpeg
handbrake
kodi
mplayer
mpv
vlc
' > importantbump
massrebuild
elif [ "${name}" = unibuild-basic ]; then
# We need disabled unitedrpms repository for a new and clean build
dnf -y config-manager --set-disabled unitedrpms

# The next line avoids a massive rebuild of sub-dependencies in our basic packages "/tmp/unibuild_basic.log"
echo 'basic build' > /tmp/unibuild_basic.log
#
up_ornew
# dnf repoquery --whatrequires unibuild-basic --source | grep -v unibuild-basic | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'unitedrpms
mock-unitedrpms
x264
x265
xvidcore
faad2
fdk-aac
libdca
live555
vcdimager
aften
opencore-amr
faac
libmms
rtmpdump
libmpeg2
nvenc
libdvdcss
vo-aacenc
vo-amrwbenc
unrar
unace
nautilus-dropbox
libaacs
celt
libdvbpsi
libmimic
openssl-spotify
openh264
kvazaar
libmysofa
shine
vmaf
libva-intel-driver
exfat-utils
broadcom-wl-dkms
ffmpeg
xine-lib
libquicktime
mlt
broadcom-bt-firmware
python3-soco
python-keyrings-alt' > importantbump
massrebuild
elif [ "${name}" = openh264 ]; then
# dnf repoquery --whatrequires openh264 --source | grep -v openh264 | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'gstreamer1-plugins-bad-freeworld' > importantbump
massrebuild
elif [ "${name}" = faad2 ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'xine-lib
mplayer
avidemux
deadbeef
gstreamer1-plugins-bad-freeworld
libquicktime
moc
mpd
vlc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'xine-lib
mplayer
avidemux
deadbeef
gstreamer1-plugins-bad-freeworld
libquicktime
moc
mpd
vlc' > importantbump
fi
massrebuild
elif [ "${name}" = faac ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'gstreamer1-plugins-bad-nonfree
mplayer' >> importantbump
elif [ ! -f importantbump ]; then
echo 'gstreamer1-plugins-bad-nonfree
mplayer' > importantbump
fi
massrebuild
#
elif [ "${name}" = kodi ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ] || [ ! -f importantbump ]; then
echo 'kodi-platform
kodi-pvr-addons
kodi-addon-visualizations' >> importantbump
elif [ ! -f importantbump ]; then
echo 'kodi-platform
kodi-pvr-addons
kodi-addon-visualizations' > importantbump
fi
massrebuild
#
elif [ "${name}" = libaacs ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'libbdplus' >> importantbump
elif [ ! -f importantbump ]; then
echo 'libbdplus' > importantbump
fi
massrebuild
#
elif [ "${name}" = vmaf ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'ffmpeg' >> importantbump
elif [ ! -f importantbump ]; then
echo 'ffmpeg' >> importantbump
fi
massrebuild
#
elif [ "${name}" = libshout-idjc ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'idjc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'idjc' > importantbump
fi
massrebuild
#
elif [ "${name}" = libopenshot ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'openshot' >> importantbump
elif [ ! -f importantbump ]; then
echo 'openshot' >> importantbump
fi
massrebuild
#
#
elif [ "${name}" = vlc ] && [ ! -f /tmp/stop ]; then
up_ornew
if [ -f importantbump ]; then
echo 'phonon-vlc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'phonon-vlc' > importantbump
fi
massrebuild
#
else
echo 'No massive dependencies found or added to list'
fi
}

Inrelease() {
# Incremental release, in massive rebuild
name_build
local_repo
#------------
# Current version 
if [ "${name}" = gstreamer1 ]; then
dnf -y download --source ${name}-devel
else
dnf -y download --source ${name}
fi
# If dnf fail downloading sources
if [ ! -f  ${name}*src.rpm ]; then
echo "failed download ${name} src.rpm source"
 fi

re_enabling_repos
sign_rpm

rpack=$(rpm -qip ${name}*src.rpm | grep : | grep 'Version' | awk '{print $3}')
curver=$(rpm -q --qf "%{version}\n" --specfile "${specfile}" | head -1)

rlc=$(rpm -qip ${name}*src.rpm | grep : | grep 'Release' | awk '{print $3}')
rlcg=$(rpm -q --qf "%{release}\n" --specfile "${specfile}" | head -1)
var=$( echo $rlcg | awk -F ".fc$(rpm -E %fedora)" '{print $1}' | awk -F ".git" '{print $1}' )

echo 'VERSIONS DETECTED IN SRC.RPM AND SPEC FILE'
echo "rpack = $rpack"
echo "curver = $curver"
echo "rlc = $rlc"
echo "rlcg = $rlcg"
echo "var = $var"

if [ -z "${rpack}" ]; then
echo "Source from repository rpm doesn't exist"
#exit 1
elif [ -z "${curver}" ]; then
echo "Spec file in massive build doesn't exist"
exit 1
fi
# deleting the source downloaded we avoid a bucle task...
rm -f ${name}*.src.rpm
#

gt=$(echo "${rpack}" > "${curver}" | bc -q )
if [ "$gt" = 1 ]; then
echo "You need update ${name}"
exit 1
elif [ "${rpack}" = "${curver}" ] && [ "${rlc}" = "${rlcg}" ]; then
echo "Same version and release for ${name}, then enabled the automatic release"
#------------
SRE=$( sed -n '/Release:/=' ${specfile} | sort | head -1 )
#rele=$(cat ${specfile} | grep "Release:" | awk '{ print $NF }' | grep -o '[0-9]*')
rele=$(cat ${specfile} | grep "Release:" | awk '{ print $NF }' | awk -F '%' '{print $1}')

if [[ $var =~ ^[-+]?[0-9]+$ ]]; then
increrele=$(($rele+1))
else
increrele=$( calc $rele + 0.01 )
fi
sed -i "${SRE}s/${rele}/${increrele}/" ${specfile}

dt=$(export LC_ALL=C && date "+%a %b %d %Y")

spver=$(rpm -q --qf "%{version}\n" --specfile ${specfile} | head -1)
specrl=$(rpm -q --qf "%{release}\n" --specfile ${specfile} | head -1 | awk -F '.fc' '{print $1}')

echo "
* $dt Unitedrpms Project <unitedrpms AT protonmail DOT com> ${spver}-${specrl}  
- Automatic Mass Rebuild

" > changdata.txt

f1="$(<changdata.txt)"

awk -vf1="$f1" '/%changelog/{print;print f1;next}1' ${specfile} | tee ${name}2.spec

mv -f ${name}2.spec ${specfile}
onedrive -v --synchronize 
else 
echo -e "\e[36mGreat, a updated package of ${name}; then the automatic release isn't necessary\e[0m"
fi

}


Pushaugit() {
# CREDENTIALS
# In massive task, our release is incremental, all change in ".spec" files is updated automatic. Maybe the sync tool give us a best security...
name_build
pushd ${directory}/rpmbuild/GIT/${name}/
find . -name "${name}*.deb" -exec rm -r {} \; 
find . -name "${name}*.tar.gz" -exec rm -r {} \; 
find . -name "${name}*.tar.xz" -exec rm -r {} \; 
find . -name "${name}*.tar" -exec rm -r {} \; 
find . -name "${name}*.zip" -exec rm -r {} \; 
find . -name "${name}*.rar" -exec rm -r {} \; 
find . -name "${name}*.rpm" -exec rm -r {} \;

if [ ! -f .gitignore ]; then
echo "BUILD/*
BUILDROOT/*
RPMS/*
SPECS/*
SRPMS/*" > .gitignore 
fi

rm -rf BUILD \
BUILDROOT \
RPMS \
SPECS \
SRPMS 
wget -c -P $HOME https://www.foo.com/.git-credentials.gpg
if [ -f ~/.git-credentials.gpg ]; then
gpg --passphrase ${TOKENG} -d ~/.git-credentials.gpg
git add .
git commit -m "Automatic Mass Rebuild"
git push origin master
rm -f ~/.git-credentials
rm -f ~/.git-credentials.gpg
fi
popd
}

chroot_dependency() {
# We can emulate a mock task with the next dependencies... https://github.com/rpm-software-management/mock/wiki/Plugin-PackageState
dnf -y clean all && rm -rf /var/lib/dnf/history

security_updates=$( dnf -y -q updateinfo list --security | awk '{print $3}' )
if [ -n "$security_updates" ]; then
dnf -y update "$security_updates"
else
dnf -y update 
fi

dnf -y install @buildsys-build python2-rpm-macros
}

local_install_packages() {
# Some times we need a massive rebuild, if we install directly built rpms; we save time
dnf -y install $( ls "${repodirectory}" | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e urpms )
}

re_enabling_repos() {
# In massive task, we compare our git version vrs repo version; and urpms makes automatic changes with incremental in release. It downloads the source and disable our repositories; we need enable again our repos...
fedora_release=$(rpm -E %fedora) 

if [ "${fedora_release}" -ge 30 ]; then
dnf -y config-manager --set-disabled rawhide-source
dnf -y config-manager --set-enabled unitedrpms
dnf -y config-manager --set-enabled rawhide
else
dnf -y config-manager --set-disabled unitedrpms-source 
dnf -y config-manager --set-disabled updates-source 
dnf -y config-manager --set-disabled fedora-source 
dnf -y config-manager --set-enabled fedora
dnf -y config-manager --set-enabled updates
dnf -y config-manager --set-enabled unitedrpms
fi
}

auth_mg() {
rm -f mppass.tar.xz
wget -c -P /root/ https://github.com/UnitedRPMS-devel/unibuild/releases/download/auth/mppass.tar.xz
pushd /root
mkdir -p /root/.config/onedrive/
tar xJf mppass.tar.xz -C /root/.config/onedrive/
pushd /root/.config/onedrive/
openssl rsautl -decrypt -inkey ./clave.pem -in key.enc -out key.txt
openssl enc -aes-256-cbc -d -pass file:key.txt -in auth.enc -out refresh_token
openssl enc -aes-256-cbc -d -pass file:key.txt -in item.enc -out items.sqlite3
if [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
mock_conf=$( echo ${TARGET} | awk -F '-' '{print $2}' | awk -F '-' '{print $1}')
sed -i "s|RELEASE|$mock_conf|g" /root/.config/onedrive/sync_list
else
sed -i "s|RELEASE|$(rpm -E %fedora)|g" /root/.config/onedrive/sync_list
fi

if [ "${REPOCLOUD}" = true ]; then
onedrive -v --synchronize 
fi

rm -f *.enc
rm -f *.pem
rm -f *.txt
rm -f /root/mppass.tar.xz
popd
popd
}

#  BEGIN THE PROGRAM

readargs "$@"

checkargs

# Absolute paths
directory=/root/build
if [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
mock_conf=$( echo ${TARGET} | awk -F '-' '{print $2}' | awk -F '-' '{print $1}')
repodirectory=/root/OneDrive/unitedrpms/updates/$mock_conf
else
repodirectory=/root/OneDrive/unitedrpms/updates/$(rpm -E %fedora)
fi
MOCK_DEF_PATH=${directory}/mock
date=$(date +%Y%m%d_%H:%M:%S)

# We need some programs
# check_depends

# Here we will make our local repository
enjoy_repo

# Mock is quite slow. In fact the whole VM/docker was quite slow, then the new changes reduces the time.
# performance_mock

# Here we will make our job directories
make_directory_task

# Rules for our directories; I changed the default path in mock, then I need rules...
rules_directory

# Python issues
# https://www.mail-archive.com/python-dev@python.org/msg95279.html
# http://bugs.python.org/issue28180#msg282964
# https://lists.fedorahosted.org/archives/list/python-devel@lists.fedoraproject.org/message/M2NMPTU74LCAFOZF7UOWHIKCWZKQ3YKP/

export PYTHONCOERCECLOCALE=0


#=== HERE BEGIN THE BUILD PROCESS === #

# START REMOTE Task only if you need rebuild a src.rpm from remote url (BETA)
if [ -n "${SRPM}" ]; then
echo -e "\e[32mDownloading and Rebuilding src.rpm ...\e[0m"
  wget -c -P $PWD/SRPMS/ ${SRPM}
# if [ -n ${NO_MOCK} ] && [ ${NO_MOCK} = true ]; then
if [ "${NO_MOCK}" = true ] && [ -n "${SRPM}" ]; then
#  dnf -y update
  chroot_dependency
  dnf -y builddep *.spec 
  rpmbuild --define "_topdir $PWD" --define "${DIST}" --rebuild $PWD/SRPMS/*.src.rpm
cp -n RPMS/x86_64/* ${MOCK_DEF_PATH}/
cp -n RPMS/i686/* ${MOCK_DEF_PATH}/
cp -n RPMS/noarch/* ${MOCK_DEF_PATH}/
cp -n SRPMS/* ${MOCK_DEF_PATH}/
else
  dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms && dnf -y update mock-core-configs
  /usr/bin/mock -r ${TARGET} --no-cleanup-after --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/*.src.rpm 
fi
  local_repo
if [ "${CLOUD}" = true ]; then
upload_rpm
fi
echo -e "\e[36mDONE...\e[0m"
exit 0
# END REMOTE URL

# START DEFAULT TASK (THE REAL TASK)
# In essential updates there are dependent packages; We have some filters for them; a massive rebuild, with incremental task.
elif [ -n "${TARGET}" ] || [ "${NO_MOCK}" = true ]; then
echo -e "\e[32mStarting complete task...\e[0m"
git_task
if [ "${CLOUD}" = true ]; then
auth_mg
fi
buildrpm
rm -rf /tmp/*.prb
# rm -rf ${repodirectory}/
rm -rf ${directory}/rpmbuild/GIT/
rm -f /tmp/unibuild_basic.log
pkill "onedrive"
echo -e "\e[36mDONE...\e[0m"
exit 0
else
usage
exit 1
fi
#  END ALL
