#!/bin/bash
#
# +-----------------------------------------------------------------------------------+
# | Copyright (C) 2017 David Vasquez                                                  |
# | MIT license                                                                       |
# | Permission is hereby granted, free of charge, to any person obtaining a copy of   |	
# | this software and associated documentation files (the "Software"), to deal in the | 
# | Software without restriction, including without limitation the rights to use,     |
# | copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the   | 
# | Software, and to permit persons to whom the Software is furnished to do so,       |
# | subject to the following conditions:                                              |
#
# | The above copyright notice and this permission notice shall be included in all    | 
# | copies or substantial portions of the Software.                                   |
#                                                       
# | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR        |
# | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS  |
# | FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR    |
# | COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN |
# | AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION   |
# | WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                   |                                                 
# +-----------------------------------------------------------------------------------+
# | This code is designed, written and maintained by David Vasquez    		      |
# | Any questions, comments or advice on this code                                    |
# | should be addressed to:                                                           |
# | davidva@tutanota.com                                                              |
# +-----------------------------------------------------------------------------------+

directory=$HOME/build
repodirectory=$HOME/enjoy
MOCK_DEF_PATH=${directory}/mock
date=$(date +%Y%m%d_%H:%M:%S)

usage() {
  echo ""
  echo -e '\e[33m  -g url_git\e[0m'
  echo "    The git hub name user and project, example UnitedRPMs/ffmpeg"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -t fedora-24-x86_64 -u true"
  echo ""
  echo -e '\e[33m  -m massive\e[0m'
  echo "    Make a massive rebuild rpm of all the organization, the task is slow (alpha)"
  echo "Usage: $0 -o UnitedRPMs -m true -t fedora-25-x86_64"
  echo ""
  echo -e '\e[33m  -r SRPM\e[0m'
  echo "    Rebuild a src.rpm from remote url (beta)"
  echo "Usage: $0 -t fedora-25-x86_64 -r http:www.foo/ffmpeg-foo.src.rpm "
  echo ""
  echo -e '\e[33m  -n SNAPSHOT\e[0m'
  echo "    Generate the source file with a special script example ffmpeg-snapshot.sh (beta)"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -t fedora-25-x86_64 -e ffmpeg-snapshot.sh "
  echo ""
  echo -e '\e[33m  -r NO_MOCK\e[0m'
  echo "    Generate a rpm without mock, super fast"
  echo "Usage: $0 -g UnitedRPMs/ffmpeg -s ffmpeg.spec -r true -d 'dist .fc25' -u true"
  echo "--------------------------------------"
  echo "  -s SPECfile"
  echo '    The name of the RPM SPEC file, example "-s ffmpeg.spec" '
  echo "  -o organization"
  echo "    The name of the organization GIT, only in massive task."
  echo "  -t TARGET"
  echo '    mock config example "-t fedora-26-x86_64" '
  echo "  -d DIST"
  echo "    Distribution number, only works with NO_MOCK; example: -r true -d 'dist .fc25' -u true"
  echo "  -u UPP"
  echo "    Unique build, avoids build without a massive task of sub-requires ; example: -r true -d 'dist .fc25' -u true"
  exit 1
}

readargs() {
  while [ "$#" -gt 0 ] ; do
    case "$1" in
       -s)
        if [ "$2" ] ; then
          specfile="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -t)
        if [ "$2" ] ; then
          TARGET="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -o)
        if [ "$2" ] ; then
          organization="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -p)
        if [ "$2" ] ; then
          TOKENG="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -g)
        if [ "$2" ] ; then
          url_git="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -b)
        if [ "$2" ] ; then
          massive_spec="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -c)
        if [ "$2" ] ; then
          CLOUD="$2" 
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -d)
        if [ "$2" ] ; then
          DIST="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -m)
        if [ "$2" ] ; then
          massive="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -n)
        if [ "$2" ] ; then
          no_who_requires="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -e)
        if [ "$2" ] ; then
          SNAPSHOT="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -r)
        if [ "$2" ] ; then
          NO_MOCK="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      -u)
        if [ "$2" ] ; then
          UPP="$2"
          shift ; shift
        else
          echo "Missing a value for $1."
          echo
          shift
          usage
        fi
      ;;
      *)
        echo "Unknown option or argument $1."
        echo
        shift
        usage
      exit
      ;;
    esac
  done
}


checkargs() {
 if [ -z "${TARGET}" ] && [ "${NO_MOCK}" = true ]; then
    echo 'Using rpmbuild mode'
 elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
    echo 'Using mock mode'
 elif [ -z "${TARGET}" ] && [ -z "${NO_MOCK}" ] ; then
    echo -e '\e[31mMissing target, example your need add "-t fedora-25-x86_64"\e[0m'
    usage
exit
  fi
}

SRPMcheck() {
name_build
counting=$( ls -1 ${directory}/rpmbuild/GIT/${name}/SRPMS/ | grep "${name}" | grep .src.rpm | wc -l )
if [ "${counting}" -ge 2 ]; then
# find $PWD/SRPMS/ -name "${name}-*.src.rpm" -mmin -2 -exec rm -f {} ';'
rm -f $( dnf -y repomanage --keep=1 --new $PWD/SRPMS/ )
exit 1
fi

ass=$(ls ${repodirectory}/${name}-*.src.rpm 2> /dev/null | wc -l)
if [ "$ass" != "0" ]; then
echo "${name} is already built"
exit 0
fi

bsource=$(ls ${directory}/rpmbuild/GIT/${name}/SRPMS/${name_spec}-*.src.rpm 2> /dev/null | wc -l)
if [ "$bsource" != "0" ]; then
   echo -e "\e[36mExists src.rpm of ${name}, great\e[0m"
else
echo "Hey the src.rpm of ${name_spec} does not exist; check your urls in sources and patches"
exit 1
fi
}

name_build() {
name=$( echo "${url_git##*/}" )
if [ -d ${directory}/rpmbuild/GIT/${name}/ ]; then
name_spec=$( rpm -q --qf "%{Name}\n" --specfile ${directory}/rpmbuild/GIT/${name}/${specfile} | head -1)
fi
}

path_chroot() {
chrootmock=${directory}/mock/${TARGET}/result
}

sign_rpm() {
rpm --define "_gpg_name The UnitedRPMs Project" --addsign *.rpm
}

make_directory_task() {
echo -e "\e[32mCreating job directories...\e[0m"
  mkdir -p ${directory}/rpmbuild/{RPMS,BUILD,SOURCES,SRPMS,GIT}
  mkdir -p ${repodirectory}
  mkdir -p ${MOCK_DEF_PATH}
  mkdir -p ${MOCK_DEF_PATH}/cache
  mkdir -p ~/.config/
}

git_task() {
echo -e "\e[32mCloning repository ${url_git}...\e[0m"
name_build
rm -rf ${directory}/rpmbuild/GIT/*
git clone https://github.com/${url_git}.git ${directory}/rpmbuild/GIT/${name}
if [ ! -f ${directory}/rpmbuild/GIT/${name}/${specfile} ]; then
echo 'Hey check if your git repository exists!'
exit 1
fi
}


detect_local_package() {
# We need detect packages already built in our local repository, useful for avoid bucles in massive rebuild
s_inrepo=$(ls ${repodirectory}/${name}-*.src.rpm 2> /dev/null | wc -l)
p_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).$(uname -m).rpm 2> /dev/null | wc -l)
n_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).noarch.rpm 2> /dev/null | wc -l)
if [ "$s_inrepo" != "0" ] && [ "$p_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
elif [ "$s_inrepo" != "0" ] && [ "$n_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
else
echo "Package ${name} not found in local repository; then we will attempt make a rpm for you, are you already test your package?"
if [ -f "/tmp/${name}.prb" ]; then
echo "ERROR loop detected with ${name} check your spec file changelog sources and patches"
exit
fi

fi
}


buildrpm() {
# Our build task
# We need detect packages already built in our local repository, useful for avoid bucles in massive rebuild
s_inrepo=$(ls ${repodirectory}/${name}-*.src.rpm 2> /dev/null | wc -l)
p_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).$(uname -m).rpm 2> /dev/null | wc -l)
n_inrepo=$(ls ${repodirectory}/${name}-*.fc$(rpm -E %fedora).noarch.rpm 2> /dev/null | wc -l)
if [ "$s_inrepo" != "0" ] && [ "$p_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
elif [ "$s_inrepo" != "0" ] && [ "$n_inrepo" != "0" ]; then
echo '1ta' > /tmp/${name}.prb
echo "${name} is already built"
return 
else
echo "Package ${name} not found in local repository; then we will attempt make a rpm for you, are you tested your package?"
if [ -f "/tmp/${name}.prb" ]; then
echo "ERROR loop detected with ${name}check your spec file changelog sources and patches"
exit
fi
 fi

echo -e "\e[32mMaking an rpm source...\e[0m"
name_build
  pushd ${directory}/rpmbuild/GIT/${name}/
if [ -n "${SNAPSHOT}" ]; then
echo 'Snapshot enabled'
  chmod a+x ${SNAPSHOT}
  ./${SNAPSHOT}
  pushd ${directory}/rpmbuild/GIT/${name}/
  find . -name \*.tar.* -exec cp {} $PWD \;
fi
if [ "${massive_spec}" = true ]; then
  Inrelease 
#  Pushaugit
fi
  spectool -g "${specfile}"
  rpmbuild --define "_topdir $PWD" --define "_sourcedir $PWD" -bs "${specfile}"
echo -e "\e[32mMaking rpm for ${name}...\e[0m"
re_enabling_repos
# if the build is with mock
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
SRPMcheck
# We need disabled unitedrpms repository for a new and clean build in unibuild-basic
if [ "${name}" = unibuild-basic ]; then
dnf -y config-manager --set-disabled unitedrpms
fi
  dnf -y update
  chroot_dependency
  dnf -y builddep "${specfile}" 
  rpmbuild --define "_topdir $PWD" --define "${DIST}" --rebuild $PWD/SRPMS/${name}-*.src.rpm | tee ${MOCK_DEF_PATH}/build.log
if [ -n $PWD/RPMS/x86_64/${name}*.rpm ] || [ -n $PWD/RPMS/i686/${name}*.rpm ] || [ -n $PWD/RPMS/noarch/${name}*.rpm ]; then
echo "Successful build for ${name}"
else
echo "Failed build ${name}, check your '%prep, %build, %install' others Sections; src.rpm made"
fi
cp -n RPMS/x86_64/* ${MOCK_DEF_PATH}/
cp -n RPMS/i686/* ${MOCK_DEF_PATH}/
cp -n RPMS/noarch/* ${MOCK_DEF_PATH}/
cp -n SRPMS/* ${MOCK_DEF_PATH}/
pushd "${MOCK_DEF_PATH}"
if [ $(ls *.rpm | grep -c .rpm) -gt 0 ]; then
dnf -y install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
fi
popd
# If the build is without mock 
elif [ -n "${TARGET}" ] && [ "${NO_MOCK}" != true ]; then
SRPMcheck
  /long-living-command &
dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms
# Conditional to accelerate the build
if [ -f importantbump ]; then
  /usr/bin/mock -r ${TARGET} --no-clean --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/${name}-*.src.rpm  
else
  /usr/bin/mock -r ${TARGET} --no-cleanup-after --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/${name}-*.src.rpm  
fi
# End conditional accelerate the build
if [ -n ${MOCK_DEF_PATH}/${name}-*.fc$(rpm -E %fedora).$(uname -m).rpm ] || [ -n ${MOCK_DEF_PATH}/${name}-*.fc$(rpm -E %fedora).noarch.rpm ]; then
echo "Successful build for ${name}"
else
echo "Failed build ${name}, check your '%prep, %build, %install' others Sections; src.rpm made"
fi
fi
  popd
local_repo
# Our conditional for build a unique build
if [ "${UPP}" = true ]; then
echo 'UNIQUE BUILD'
else
if [ "${no_who_requires}" = true ]; then
up_ornew
fi
massdependency
fi
# End unique build conditional

# Delete trash
if [ -f /tmp/stop ]; then
if [ "${no_who_requires}" = true ]; then
echo "You disabled the massive rebuild, don't worry"
else
rm -f /tmp/stop
fi
fi
#

# Conditional for sync to MEGA 
if [ "${CLOUD}" = true ]; then
upload_rpm
fi
# End conditional MEGA
}

local_repo() {
# Our local repo; useful in massive rebuild
enjoy_repo
path_chroot
name_build
echo -e "\e[32mMaking local repository...\e[0m"
pushd ${MOCK_DEF_PATH}/
cp -f *.rpm ${repodirectory}/ 
 popd
pushd "${repodirectory}"
rm -rf repodata/
 rm -f $( dnf -y repomanage --keep=1 --old $PWD )
sign_rpm
createrepo .
#
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
dnf -y clean expire-cache
dnf -y install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
elif [ -z "${NO_MOCK}" ] && [ -n "${TARGET}" ]; then
mock -r "${TARGET}" --install $( ls *.rpm | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e importantbump )
fi
#
popd
}

enjoy_repo() {

if [ ! -d "${repodirectory}" ]; then
mkdir -p "${repodirectory}"
fi

if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ] && [ "${massive_spec}" != true ] && [ "${massive}" != true ]; then
echo '
[enjoy]
name=enjoy
baseurl=file:///root/enjoy
enabled=1
skip_if_unavailable=1
gpgcheck=0
exclude=*.src.rpm
' > /etc/yum.repos.d/enjoy.repo
elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ] && [ "${massive_spec}" != true ] && [ "${massive}" != true ]; then
if [ ! -f /etc/mock/${TARGET}.cfg ]; then
echo 'The build config mock does not exist'
echo 'Check your configuration or update your mock package'
usage
exit 1
fi
echo '
[enjoy]
name=enjoy
baseurl=file:///root/enjoy
enabled=1
skip_if_unavailable=1
gpgcheck=0
exclude=*.src.rpm
' > changdata.txt 

f1="$(<changdata.txt)"
awk -vf1="$f1" '/# repos/{print;print f1;next}1' /etc/mock/${TARGET}.cfg | tee /tmp/new_repo.cfg
pushd /etc/mock/
mv -f /tmp/new_repo.cfg ${TARGET}.cfg
 popd
fi
}

upload_rpm() {
echo -e "\e[32mUploading results...\e[0m"
pushd "${repodirectory}"
ls *.rpm | sort > output-result.txt
sign_rpm

if [ -n "${TARGET}" ]; then
cp -f ${MOCK_DEF_PATH}/build.log ${name}_${date}_build.log
cp -f ${MOCK_DEF_PATH}/root.log ${name}_${date}_root.log
cp -f ${MOCK_DEF_PATH}/state.log ${name}_${date}_state.log
megaput ${name}_${date}_build.log --path /Root/logs/
megaput ${name}_${date}_root.log --path /Root/logs/
megaput ${name}_${date}_state.log --path /Root/logs/
fi

megals --names /Root/unitedrpms/updates/24/ > megalist24
megals --names /Root/unitedrpms/updates/25/ > megalist25
megals --names /Root/unitedrpms/updates/26/ > megalist26
megals --names /Root/unitedrpms/updates/27/ > megalist27
megals --names /Root/unitedrpms/updates/28/ > megalist28
megals --names /Root/unitedrpms/updates/29/ > megalist29
megals --names /Root/unitedrpms/updates/30/ > megalist30

Ou=output-result.txt
while IFS= read -r result; do
if [ $(ls $result | grep -c .fc24.) -gt 0 ] && [ $(cat megalist24 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/24/
elif [ $(ls $result | grep -c .fc25.) -gt 0 ] && [ $(cat megalist25 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/25/
elif [ $(ls $result | grep -c .fc26.) -gt 0 ] && [ $(cat megalist26 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/26/
elif [ $(ls $result | grep -c .fc27.) -gt 0 ] && [ $(cat megalist27 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/27/
elif [ $(ls $result | grep -c .fc28.) -gt 0 ] && [ $(cat megalist28 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/28/
elif [ $(ls $result | grep -c .fc29.) -gt 0 ] && [ $(cat megalist29 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/29/
elif [ $(ls $result | grep -c .fc30.) -gt 0 ] && [ $(cat megalist30 | grep -c $result) -lt 1 ]; then
megaput $result --path /Root/unitedrpms/updates/30/
fi
done <"$Ou"
echo -e "\e[35mSynced with Mega Successfully...\e[0m"
rm -f output-result.txt
popd

zlog=$( du -k ${MOCK_DEF_PATH}/build.log | cut -f1 )
b=800
if [ -n "${TARGET}" ] && [ $zlog \> $b ] || [ "${massive_spec}" = true ] || [ "${NO_MOCK}" = true ]; then
echo 'This log is too long to be displayed'
elif [ -n "${TARGET}" ] && [ "$b" -gt "$zlog" ]; then
cat ${MOCK_DEF_PATH}/build.log
fi
}

rules_directory() {
# I am not sure, we are root...
chown -R 1000:1000 ${directory}
chown -R 1000:1000 ${repodirectory}
# chown -R 1000:1000 ${MOCK_DEF_PATH}
chmod g+rws ${MOCK_DEF_PATH}
chmod g+rws ${MOCK_DEF_PATH}/cache
}


performance_mock() {
# NO TOUCH OR ENABLE IT! It alters the mock function
echo 'config_opts['basedir'] = '/home/makerpm/mock/'
config_opts['cache_topdir'] = '/home/makerpm/mock/cache'
config_opts['use_container_host_hostname'] = True
config_opts['docker_unshare_warning'] = False
config_opts['nosync_force'] = True
config_opts['plugin_conf']['tmpfs_enable'] = True
config_opts['plugin_conf']['tmpfs_opts'] = {}
config_opts['plugin_conf']['tmpfs_opts']['required_ram_mb'] = 1024
config_opts['plugin_conf']['tmpfs_opts']['max_fs_size'] = '50g'
config_opts['plugin_conf']['tmpfs_opts']['mode'] = '0755'
config_opts['plugin_conf']['tmpfs_opts']['keep_mounted'] = False
' > perf.txt

f1="$(<perf.txt)"
awk -vf1="$f1" '/package_manager/{print;print f1;next}1' /etc/mock/${TARGET}.cfg | tee /tmp/new_perf.cfg
pushd /etc/mock/
mv -f /tmp/new_perf.cfg ${TARGET}.cfg
 popd
}

check_depends() {
# only necessary in Performance mock task
if [ ! -f /usr/lib64/nosync/nosync.so ]; then
dnf -y install nosync 
fi
}

up_ornew() {
# The filer for a initial package or unique, useful in new versions of fedora
echo 'no_build' > /tmp/stop
if [ ${name} = ffmpeg ]; then
echo 'ffmpeg_build' >> /tmp/stop
elif [ ${name} = x264 ]; then
echo 'x264_build' >> /tmp/stop
elif [ ${name} = x265 ]; then
echo 'x265_build' >> /tmp/stop
elif [ ${name} = libbluray ]; then
echo 'libbluray_build' >> /tmp/stop
elif [ ${name} = kodi ]; then
echo 'kodi_build' >> /tmp/stop
elif [ ${name} = libquicktime ]; then
echo 'libquicktime_build' >> /tmp/stop
fi
}

massrebuild() {
# Our massive task
if [ -f importantbump ] && [ ! -f /tmp/unibuild_basic.log ] || [ $( cat /tmp/stop | grep -c -e ffmpeg_build -e x264_build -e x265_build -e libbluray_build -e kodi_build -e libquicktime_build ) -lt 1 ]; then

file=importantbump

if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
local_install_packages
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -r true -d "${DIST}" -b true
done <"$file"
local_repo

elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -t "${TARGET}" -b true
done <"$file"
local_repo
fi
# FIRST BUILD
elif [ -f importantbump ] && [ -f /tmp/unibuild_basic.log ] || [ $( cat /tmp/stop | grep -c -e ffmpeg_build -e x264_build -e x265_build -e libbluray_build -e kodi_build -e libquicktime_build ) -gt 0 ]; then
echo 'FIRST BUILD TASK'
file=importantbump
if [ "${NO_MOCK}" = true ] && [ -z "${TARGET}" ]; then
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -t "${TARGET}" -u true
done <"$file"
local_repo
elif [ -n "${TARGET}" ] && [ -z "${NO_MOCK}" ]; then
while IFS= read -r line; do
        # display $line or do something with $line
/urpms -g UnitedRPMs/$line -s $line.spec -r true -d "${DIST}" -u true 
done <"$file"
local_repo
fi
else
echo 'mass rebuild failed'
exit 1
 fi
}

massdependency() {
# Some times we need a filter with massive rebuild... the /tmp/stop (dummy) makes a special build wihout packages dependent of the current build.
# importantbump, is a list of all packages dependent of the current build (called massive rebuild)
name_build
if [ "${name}" = x264 ] || [ "${name}" = x265 ]; then
# dnf repoquery --whatrequires x264-libs --source | grep -v x264 | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
up_ornew

if [ "${name}" = x264 ] && [ -f /tmp/stop ]; then
echo 'ffmpeg
libquicktime
mplayer
gstreamer1-plugins-ugly
avidemux
handbrake
obs-studio
vlc' > importantbump
elif [ "${name}" = x265 ] && [ -f /tmp/stop ]; then
echo 'ffmpeg
gstreamer1-plugins-bad-freeworld
avidemux
handbrake
vlc' > importantbump
elif [ "${name}" = x265 ] || [ "${name}" = x264 ] && [ ! -f /tmp/stop ]; then 
echo 'x264
x265
ffmpeg
avidemux
handbrake
gstreamer1-plugins-bad-freeworld' > importantbump
fi
massrebuild
elif [ "${name}" = ffmpeg ]; then
up_ornew
if [ -f importantbump ]; then
echo 'xine-lib
gstreamer1-libav
gstreamer-ffmpeg
libquicktime
mlt
libopenshot
idjc
minidlna
mplayer
moc
mpd
mpv
obs-studio
simplescreenrecorder
vlc
kodi' >> importantbump
elif [ ! -f importantbump ]; then
echo 'xine-lib
gstreamer1-libav
gstreamer-ffmpeg
libquicktime
mlt
libopenshot
idjc
minidlna
mplayer
moc
mpd
mpv
obs-studio
simplescreenrecorder
vlc
kodi' > importantbump
fi
massrebuild
elif [ "${name}" = libquicktime ] && [ ! -f /tmp/stop ]; then
# dnf repoquery --whatrequires libquicktime --source | grep -v libquicktime | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
if [ -f importantbump ]; then
echo 'mjpegtools' >> importantbump
else
echo 'mjpegtools' > importantbump
fi
massrebuild
elif [ "${name}" = gstreamer1 ] && [ ! -f /tmp/stop ]; then
echo 'gstreamer1-plugins-base' > importantbump
massrebuild
elif [ "${name}" = gstreamer1-plugins-base ] && [ ! -f /tmp/stop ]; then
echo 'gstreamer1-plugins-good
gstreamer1-plugins-bad-free
gstreamer1-plugins-bad-nonfree
gstreamer1-plugins-bad-freeworld
gstreamer1-plugins-ugly
gstreamer1-libav' > importantbump
massrebuild
elif [ "${name}" = live555 ] && [ ! -f /tmp/stop ]; then
# dnf repoquery --whatrequires live555 --source | grep -v libquicktime | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
if [ -f importantbump ]; then
echo 'vlc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'vlc' > importantbump
fi
massrebuild
elif [ "${name}" = libbluray ]; then
up_ornew
# dnf repoquery --whatrequires libbluray --source | grep -v libbluray | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'xine-lib
ffmpeg
handbrake
kodi
mplayer
mpv
vlc
' > importantbump
massrebuild
elif [ "${name}" = dtksettings ]; then
# dnf repoquery --whatrequires dtksettings --source | grep -v dtksettings | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'deepin-tool-kit' > importantbump
massrebuild
elif [ "${name}" = deepin-tool-kit ]; then
# dnf repoquery --whatrequires deepin-tool-kit --source | grep -v deepin-tool-kit | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'deepin-music' > importantbump
massrebuild
elif [ "${name}" = unibuild-basic ]; then
# We need disabled unitedrpms repository for a new and clean build
dnf -y config-manager --set-disabled unitedrpms

# The next line avoids a massive rebuild of sub-dependencies in our basic packages "/tmp/unibuild_basic.log"
echo 'basic build' > /tmp/unibuild_basic.log
#
up_ornew
# dnf repoquery --whatrequires unibuild-basic --source | grep -v unibuild-basic | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'x264
x265
xvidcore
faad2
libdca
live555
twolame
vcdimager
aften
opencore-amr
faac
libmms
rtmpdump
libmpeg2
nvenc
libdvdcss
vo-aacenc
vo-amrwbenc
unrar
unace
nautilus-dropbox
libaacs
celt
libdvbpsi
libmimic
libmng
openssl-spotify
openh264' > importantbump
massrebuild
elif [ "${name}" = openh264 ]; then
# dnf repoquery --whatrequires openh264 --source | grep -v openh264 | perl -pe 's/-\d.*?-\d+(\..*)?\.fc\d+(\..*)?.src.rpm//' | sort -u > importantbump
echo 'gstreamer1-plugins-bad-freeworld' > importantbump
massrebuild
elif [ "${name}" = faad2 ] && [ ! -f /tmp/stop ]; then

if [ -f importantbump ]; then
echo 'xine-lib
mplayer
avidemux
deadbeef
gstreamer1-plugins-bad-freeworld
libquicktime
moc
mpd
vlc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'xine-lib
mplayer
avidemux
deadbeef
gstreamer1-plugins-bad-freeworld
libquicktime
moc
mpd
vlc' > importantbump
fi
massrebuild
elif [ "${name}" = faac ] && [ ! -f /tmp/stop ]; then

if [ -f importantbump ]; then
echo 'gstreamer1-plugins-bad-nonfree
mplayer' >> importantbump
elif [ ! -f importantbump ]; then
echo 'gstreamer1-plugins-bad-nonfree
mplayer' > importantbump
fi
massrebuild
#
elif [ "${name}" = kodi ] && [ ! -f /tmp/stop ]; then

if [ -f importantbump ]; then
echo 'kodi-platform
kodi-pvr-addons
kodi-addon-visualizations' >> importantbump
elif [ ! -f importantbump ]; then
echo 'kodi-platform
kodi-pvr-addons
kodi-addon-visualizations' > importantbump
fi
massrebuild
#
elif [ "${name}" = libaacs ] && [ ! -f /tmp/stop ]; then

if [ -f importantbump ]; then
echo 'libbdplus' >> importantbump
elif [ ! -f importantbump ]; then
echo 'libbdplus' > importantbump
fi
massrebuild
#
elif [ "${name}" = libshout-idjc ] && [ ! -f /tmp/stop ]; then

if [ -f importantbump ]; then
echo 'idjc' >> importantbump
elif [ ! -f importantbump ]; then
echo 'idjc' > importantbump
fi
massrebuild
#
else
echo 'No massive dependencies found or added to list'
fi
}

Inrelease() {
# Incremental release, in massive rebuild
name_build
local_repo
#------------
# Current version 
if [ "${name}" = gstreamer1 ]; then
dnf -y download --source ${name}-devel
else
dnf -y download --source ${name}
fi
# If dnf fail downloading sources
if [ ! -f  ${name}*src.rpm ]; then
echo 'yumdownloader mode'
if [ "${name}" = gstreamer1 ]; then
yumdownloader -y --source ${name}-devel
else
yumdownloader -y --source ${name}
fi
 fi

re_enabling_repos
sign_rpm

rpack=$(rpm -qip ${name}*src.rpm | grep : | grep 'Version' | awk '{print $3}')
curver=$(rpm -q --qf "%{version}\n" --specfile "${specfile}" | head -1)

rlc=$(rpm -qip ${name}*src.rpm | grep : | grep 'Release' | awk '{print $3}')
rlcg=$(rpm -q --qf "%{release}\n" --specfile "${specfile}" | head -1)

echo 'VERSIONS DETECTED IN SRC.RPM AND SPEC FILE'
echo "rpack = $rpack"
echo "curver = $curver"
echo "rlc = $rlc"
echo "rlcg = $rlcg"

if [ -z "${rpack}" ]; then
echo "Source from repository rpm doesn't exist"
#exit 1
elif [ -z "${curver}" ]; then
echo "Spec file in massive build doesn't exist"
exit 1
fi
# deleting the source downloaded we avoid a bucle task...
rm -f ${name}*.src.rpm
#

gt=$(echo "${rpack}" > "${curver}" | bc -q )
if [ "$gt" = 1 ]; then
echo "You need update ${name}"
exit 1
elif [ "${rpack}" = "${curver}" ] && [ "${rlc}" = "${rlcg}" ]; then
echo "Same version and release for ${name}, then enabled the automatic release"
#------------
SRE=$( sed -n '/Release:/=' ${specfile} | sort | head -1 )
#rele=$(cat ${specfile} | grep "Release:" | awk '{ print $NF }' | grep -o '[0-9]*')
rele=$(cat ${specfile} | grep "Release:" | awk '{ print $NF }' | awk -F '%' '{print $1}')

if [[ $var =~ ^[-+]?[0-9]+$ ]]; then
increrele=$(($rele+1))
else
increrele=$( calc $rele + 0.01 )
fi
sed -i "${SRE}s/${rele}/${increrele}/" ${specfile}

dt=$(export LC_ALL=C && date "+%a %b %d %Y")

spver=$(rpm -q --qf "%{version}\n" --specfile ${specfile} | head -1)
specrl=$(rpm -q --qf "%{release}\n" --specfile ${specfile} | head -1 | awk -F '.fc' '{print $1}')

echo "
* $dt Unitedrpms Project <unitedrpms AT protonmail DOT com> ${spver}-${specrl}  
- Automatic Mass Rebuild

" > changdata.txt

f1="$(<changdata.txt)"

awk -vf1="$f1" '/%changelog/{print;print f1;next}1' ${specfile} | tee ${name}2.spec

mv -f ${name}2.spec ${specfile}
megaput ${specfile} --path /Root/unitedrpms/automatic-release/
else 
echo -e "\e[36mGreat, a updated package of ${name}; then the automatic release isn't necessary\e[0m"
fi

}


Pushaugit() {
# CREDENTIALS
# In massive task, our release is incremental, all change in ".spec" files is updated automatic. Maybe the sync tool give us a best security...
name_build
pushd ${directory}/rpmbuild/GIT/${name}/
find . -name "${name}*.deb" -exec rm -r {} \; 
find . -name "${name}*.tar.gz" -exec rm -r {} \; 
find . -name "${name}*.tar.xz" -exec rm -r {} \; 
find . -name "${name}*.tar" -exec rm -r {} \; 
find . -name "${name}*.zip" -exec rm -r {} \; 
find . -name "${name}*.rar" -exec rm -r {} \; 
find . -name "${name}*.rpm" -exec rm -r {} \;

if [ ! -f .gitignore ]; then
echo "BUILD/*
BUILDROOT/*
RPMS/*
SPECS/*
SRPMS/*" > .gitignore 
fi

rm -rf BUILD \
BUILDROOT \
RPMS \
SPECS \
SRPMS 
wget -c -P $HOME https://www.foo.com/.git-credentials.gpg
if [ -f ~/.git-credentials.gpg ]; then
gpg --passphrase ${TOKENG} -d ~/.git-credentials.gpg
git add .
git commit -m "Automatic Mass Rebuild"
git push origin master
rm -f ~/.git-credentials
rm -f ~/.git-credentials.gpg
fi
popd
}

chroot_dependency() {
# We can emulate a mock task with the next dependencies... https://github.com/rpm-software-management/mock/wiki/Plugin-PackageState
dnf -y clean packages
dnf -y install @buildsys-build
}

local_install_packages() {
# Some times we need a massive rebuild, if we install directly built rpms; we save time
dnf -y install $( ls "${repodirectory}" | grep .rpm | grep -ve .src.rpm -e debuginfo -e debugsource -e repodata -e enjoy -e urpms )
}

re_enabling_repos() {
# In massive task, we compare our git version vrs repo version; and urpms makes automatic changes with incremental in release. It downloads the source and disable our repositories; we need enable again our repos...
fedora_release=$(rpm -E %fedora) 

if [ "${fedora_release}" -ge 28 ]; then
dnf -y config-manager --set-disabled rawhide-source
dnf -y config-manager --set-enabled unitedrpms
dnf -y config-manager --set-enabled rawhide
else
dnf -y config-manager --set-disabled unitedrpms-source 
dnf -y config-manager --set-disabled updates-source 
dnf -y config-manager --set-disabled fedora-source 
dnf -y config-manager --set-enabled fedora
dnf -y config-manager --set-enabled updates
dnf -y config-manager --set-enabled unitedrpms
fi
}

#  BEGIN THE PROGRAM

readargs "$@"

checkargs

# We need some programs
# check_depends

# Here we will make our local repository
enjoy_repo

# Mock is quite slow. In fact the whole VM/docker was quite slow, then the new changes reduces the time.
# performance_mock

# Here we will make our job directories
make_directory_task

# Rules for our directories; I changed the default path in mock, then I need rules...
rules_directory

# Python issues
# https://www.mail-archive.com/python-dev@python.org/msg95279.html
# http://bugs.python.org/issue28180#msg282964
# https://lists.fedorahosted.org/archives/list/python-devel@lists.fedoraproject.org/message/M2NMPTU74LCAFOZF7UOWHIKCWZKQ3YKP/

export PYTHONCOERCECLOCALE=0


#=== HERE BEGIN THE BUILD PROCESS === #

# MASSIVE REBUILD TASK ORGANIZATION, YOU NEED A POWERFULL MACHINE (BETA)
# Our massive organization rebuild has no concept of packages version, it will give you the most recently tagged ones in git repository... we need a similar model to "default build".
if [ "${massive}" = true ]; then
echo -e "\e[35mStarting massive task...\e[0m"
rm -f ${directory}/${organization}.txt
curl -s https://api.github.com/orgs/${organization}/repos?per_page=200 | grep html_url | grep "${organization}/" | awk -F '"html_url": "' '{print $2}' | awk -F '",' '{print $1}' | sed 's/$/.git/' | tee ${directory}/${organization}.txt

# clone all git repositories
echo -e "\e[32mCloning all repositories ${url_git}...\e[0m"
pushd ${directory}/rpmbuild/GIT/
file=${directory}/${organization}.txt
while IFS= read -r line; do
        # display $line or do something with $line
    git clone $line 
done <"$file"

# srpm and build task
echo -e "\e[32mMaking rpm...\e[0m"
rm -f repositories.txt
ls -d */ | sed 's:/::g' | grep -v "chromium-freeworld" | tee repositories.txt
file=repositories.txt
while IFS= read -r liner; do
        # display $liner or do something with $liner
pushd $liner
# Start checking if exist a spec file
if [ $(ls | grep -c $liner.spec) -gt 0 ]; then
  spectool -g $liner.spec
  rpmbuild --define "_topdir $PWD" --define "_sourcedir $PWD" -bs $liner.spec
#  if [ -n ${NO_MOCK} ] && [ ${NO_MOCK} = true ]; then
if [ "${NO_MOCK}" = true ] && [ "${massive}" = true ]; then
# We need disabled unitedrpms repository for a new and clean build in unibuild-basic
if [ "${name}" = unibuild-basic ]; then
dnf -y config-manager --set-disabled unitedrpms
fi
  dnf -y update
  chroot_dependency
  dnf -y builddep *.spec 
  rpmbuild --define "_topdir $PWD" --define "${DIST}" --rebuild $PWD/SRPMS/$liner-*.src.rpm | tee ${MOCK_DEF_PATH}/build.log
cp -n RPMS/x86_64/* ${MOCK_DEF_PATH}/
cp -n RPMS/i686/* ${MOCK_DEF_PATH}/
cp -n RPMS/noarch/* ${MOCK_DEF_PATH}/
cp -n SRPMS/* ${MOCK_DEF_PATH}/
 else
  dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms
  /usr/bin/mock -r ${TARGET} --no-cleanup-after --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/$liner-*.src.rpm 
fi
#
local_repo
else
echo "the repository $liner does not include a spec file"
fi
# End check spec file
popd  
done <"$file"
popd  
local_repo
if [ "${CLOUD}" = true ]; then
upload_rpm
fi
echo -e "\e[36mDONE...\e[0m"
exit 0
# END MASSIVE TASK ORGANIZATION

# START REMOTE Task only if you need rebuild a src.rpm from remote url (BETA)
elif [ -n "${SRPM}" ] && [ "${massive}" != true ]; then
echo -e "\e[32mDownloading and Rebuilding src.rpm ...\e[0m"
  wget -c -P $PWD/SRPMS/ ${SRPM}
# if [ -n ${NO_MOCK} ] && [ ${NO_MOCK} = true ]; then
if [ "${NO_MOCK}" = true ] && [ -n "${SRPM}" ] && [ "${massive}" != true ]; then
  dnf -y update
  chroot_dependency
  dnf -y builddep *.spec 
  rpmbuild --define "_topdir $PWD" --define "${DIST}" --rebuild $PWD/SRPMS/*.src.rpm
cp -n RPMS/x86_64/* ${MOCK_DEF_PATH}/
cp -n RPMS/i686/* ${MOCK_DEF_PATH}/
cp -n RPMS/noarch/* ${MOCK_DEF_PATH}/
cp -n SRPMS/* ${MOCK_DEF_PATH}/
else
  dnf -y install mock-unitedrpms && dnf -y update mock && dnf -y update mock-unitedrpms
  /usr/bin/mock -r ${TARGET} --no-cleanup-after --resultdir=${MOCK_DEF_PATH} $PWD/SRPMS/*.src.rpm 
fi
  local_repo
if [ "${CLOUD}" = true ]; then
upload_rpm
fi
echo -e "\e[36mDONE...\e[0m"
exit 0
# END REMOTE URL

# START DEFAULT TASK, WITHOUT MASSIVE REBUILD ORGANIZATION (THE REAL TASK)
# In essential updates there are dependent packages; We have some filters for them; a massive rebuild, with incremental task.
elif [ -n "${TARGET}" ] || [ "${NO_MOCK}" = true ] && [ "${massive}" != true ]; then
echo -e "\e[32mStarting complete task...\e[0m"
git_task
buildrpm
rm -rf /tmp/*.prb
# rm -rf ${repodirectory}/
rm -rf ${directory}/rpmbuild/GIT/
rm -f /tmp/unibuild_basic.log
pkill "megaput"
echo -e "\e[36mDONE...\e[0m"
exit 0
else
usage
exit 1
fi
#  END ALL
